<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Tilde Markdown Browser v30</title>
    <link rel="icon" type="image/png" href="/Kietera-dev/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/Kietera-dev/favicon.svg" />
    <link rel="shortcut icon" href="/Kietera-dev/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/Kietera-dev/apple-touch-icon.png" />
    <link rel="manifest" href="/Kietera-dev/site.webmanifest" />
    <meta name="apple-mobile-web-app-title" content="~" />
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: Georgia, serif;
            line-height: 1.6;
            padding-top: 80px; /* Space for fixed nav */
        }
        .nav-container {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 20px;
            box-sizing: border-box;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid #ccc;
        }
        .mode-toggle {
            font-size: 20px;
            cursor: pointer;
            color: #666;
            user-select: none;
        }
        .source-indicator {
            font-size: 11px;
            letter-spacing: 1px;
            color: #666;
            font-family: Georgia, serif;
            font-variant: small-caps;
            width: 80px; /* Fixed width */
            text-align: center;
        }
        .source-indicator .active {
            font-weight: bold;
            color: #333;
        }
        /* Theme styles */
        body.light {
            background: #fff;
            color: #222;
        }
        body.dark {
            background: #222;
            color: #ddd;
        }
        body.sepia {
            background: #f4ecd8;
            color: #5b4636;
        }
        .dark input {
            background: #333;
            color: #ddd;
            border-color: #444;
        }
        .dark .input-indicator,
        .dark .mode-toggle,
        .dark .back-button,
        .dark .font-button {
            color: #888;
        }
        .sepia input {
            background: #f4ecd8;
            color: #5b4636;
            border-color: #d3c4b0;
        }
        .dark .nav-container {
            background: #222;
            border-color: #444;
        }
        .sepia .nav-container {
            background: #f4ecd8;
            border-color: #d3c4b0;
        }
        .back-button {
            color: #666;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
            opacity: 0.3;
            transition: opacity 0.2s;
        }
        .back-button.active {
            opacity: 1;
        }
        .url-container {
            position: relative;
            flex: 1;
            min-width: 0; /* Prevents flex item from overflowing */
            display: flex;
            align-items: center;
        }
        input {
            width: 100%;
            padding: 5px 30px 5px 10px;
            font-family: Georgia, serif;
            font-size: 16px;
            border: 1px solid #ccc;
        }
        .input-indicator {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            font-size: 20px;
            pointer-events: none;
            display: inline-block;
            /* No transition for hard flips */
            transition: none;
        }
        .font-button {
            font-size: 18px;
            cursor: pointer;
            color: #666;
            margin-left: 5px;
            user-select: none;
        }
        /* Font panel styles */
        .font-panel {
            position: fixed;
            top: 80px;
            right: calc(50% - 400px);
            width: 200px;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 15px;
            display: none;
            z-index: 101;
        }
        .dark .font-panel {
            background: #222;
            border-color: #444;
        }
        .sepia .font-panel {
            background: #f4ecd8;
            border-color: #d3c4b0;
        }
        .font-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .font-row {
            display: flex;
            align-items: center;
            width: 100%;
        }
        .font-sample {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            padding: 0 5px;
        }
        .font-sample:hover {
            background: #f5f5f5;
        }
        .dark .font-sample:hover {
            background: #333;
        }
        .sepia .font-sample:hover {
            background: #ebe3d1;
        }
        .size-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 10px;
            font-weight: bold;
            user-select: none;
        }
        .size-value {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 3px;
            margin-left: 10px;
            font-size: 12px;
        }
        #content {
            border-top: 1px solid #ccc;
            padding-top: 20px;
        }
        /* Markdown styles */
        h1, h2, h3 { margin-top: 1.5em; }
        code { 
            background: #f5f5f5;
            padding: 2px 5px;
        }
        blockquote {
            border-left: 3px solid #ccc;
            margin: 0;
            padding-left: 1em;
        }
        a {
            text-decoration: none;
            color: #555;
            padding: 0 2px;
            border-bottom: 1px solid #ddd;
        }
        a:hover {
            color: #111;
            border-bottom-color: #999;
        }
        a:visited {
            color: #666;
        }
        /* RTL support */
        body.rtl {
            direction: rtl;
            text-align: right;
        }
        .rtl .input-indicator {
            right: auto;
            left: 10px;
            transform: translateY(-50%);
        }
        .rtl input {
            padding: 5px 10px 5px 30px;
            text-align: right;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1.5em 0;
        }
        th, td {
            text-align: left;
            padding: 8px;
            border-bottom: 0.5px solid #e0e0e0;
        }
        thead th {
            border-bottom: 0.5px solid #999;
        }
    </style>
</head>
<body>
    <div class="nav-container">
        <span class="back-button">←</span>
        <div class="url-container">
            <input type="url" id="url" placeholder="Enter markdown URL">
            <span class="input-indicator">~</span>
        </div>
        <div class="source-indicator">
            <span class="native">native</span>
            <span class="dot">·</span>
            <span class="converted">converted</span>
        </div>
        <span class="font-button">A</span>
        <span class="mode-toggle">☼</span>
    </div>
    <div id="content"></div>
    
    <div class="font-panel">
        <div class="font-grid">
            <div class="font-row">
                <div class="font-sample" style="font-family: Georgia, serif;">Ga</div>
                <div class="size-button" id="font-size-increase">+</div>
            </div>
            <div class="font-row">
                <div class="font-sample" style="font-family: 'Times New Roman', Times, serif;">Ti</div>
                <div class="size-value" id="font-size-value">100%</div>
            </div>
            <div class="font-row">
                <div class="font-sample" style="font-family: Arial, sans-serif;">Ar</div>
                <div class="size-button" id="font-size-decrease">-</div>
            </div>
            <div class="font-row">
                <div class="font-sample" style="font-family: 'Courier New', monospace;">Co</div>
            </div>
            <div class="font-row">
                <div class="font-sample" style="font-family: Palatino, 'Palatino Linotype', serif;">Pa</div>
            </div>
            <div class="font-row">
                <div class="font-sample" style="font-family: Verdana, sans-serif;">Ve</div>
            </div>
        </div>
    </div>

    <script>
        const urlInput = document.getElementById('url');
        const contentDiv = document.getElementById('content');
        const backButton = document.querySelector('.back-button');
        const indicator = document.querySelector('.input-indicator');
        const fontButton = document.querySelector('.font-button');
        const fontPanel = document.querySelector('.font-panel');
        const fontSamples = document.querySelectorAll('.font-sample');
        const fontSizeValue = document.getElementById('font-size-value');
        const fontSizeIncrease = document.getElementById('font-size-increase');
        const fontSizeDecrease = document.getElementById('font-size-decrease');
        
        // Initialize font size
        let currentFontSize = 100;
        
        // Font panel toggle
        fontButton.addEventListener('click', () => {
            fontPanel.style.display = fontPanel.style.display === 'block' ? 'none' : 'block';
        });
        
        // Close font panel when clicking outside
        document.addEventListener('click', (e) => {
            if (!fontPanel.contains(e.target) && e.target !== fontButton) {
                fontPanel.style.display = 'none';
            }
        });
        
        // Font selection
        fontSamples.forEach(sample => {
            sample.addEventListener('click', () => {
                document.body.style.fontFamily = sample.style.fontFamily;
                // Update font samples to maintain their own fonts
                fontSamples.forEach(s => {
                    s.style.fontFamily = s.getAttribute('data-font') || s.style.fontFamily;
                });
            });
            // Store original font family
            sample.setAttribute('data-font', sample.style.fontFamily);
        });
        
        // Font size buttons
        fontSizeIncrease.addEventListener('click', () => {
            currentFontSize += 10;
            updateFontSize();
        });
        
        fontSizeDecrease.addEventListener('click', () => {
            if (currentFontSize > 50) {
                currentFontSize -= 10;
                updateFontSize();
            }
        });
        
        function updateFontSize() {
            document.body.style.fontSize = (currentFontSize / 100) + 'em';
            fontSizeValue.textContent = currentFontSize + '%';
        }
        
        // Direction toggle (Ctrl+Shift+D)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                document.body.classList.toggle('rtl');
            }
        });
        
        // Hard flip tilde animation
        let tildeFlipped = false;
        let tildeAnimationInterval = null;
        
        function startTildeAnimation() {
            tildeAnimationInterval = setInterval(() => {
                tildeFlipped = !tildeFlipped;
                if (tildeFlipped) {
                    indicator.style.transform = 'translateY(-50%) scaleX(-1)';
                } else {
                    indicator.style.transform = 'translateY(-50%) scaleX(1)';
                }
            }, 400);
        }
        
        function stopTildeAnimation() {
            clearInterval(tildeAnimationInterval);
            indicator.style.transform = 'translateY(-50%) scaleX(1)';
            indicator.textContent = '~';
        }
        
        // History management
        const history = [];
        let currentIndex = -1;
        
        async function tryFetch(url) {
            try {
                console.log('Trying to fetch:', url);
                const response = await fetch(url);
                if (response.ok) {
                    return await response.text();
                }
                console.log('Failed with status:', response.status, 'for URL:', url);
                return null;
            } catch (error) {
                console.log('Error fetching:', url, error);
                return null;
            }
        }

        // Improved markdown detection that ignores query strings
        function isMdFile(url) {
            // Remove query string and hash if present
            const urlWithoutQuery = url.split(/[?#]/)[0];
            
            return urlWithoutQuery.toLowerCase().endsWith('.md') || 
                   urlWithoutQuery.toLowerCase().endsWith('.markdown') ||
                   urlWithoutQuery.toLowerCase().includes('/blob/') && urlWithoutQuery.toLowerCase().includes('.md');
        }

        async function fetchContent(url, isNavigation = true) {
            indicator.textContent = '~'; // Ensure we start with the tilde character
            startTildeAnimation();
            
            let content = null;
            let isNative = false;
            
            // Try direct URL if it's markdown
            if (isMdFile(url)) {
                content = await tryFetch(url);
                if (content) isNative = true;
            }
            
            // Try appending index.md
            if (!content && !isMdFile(url)) {
                const mdUrl = url.endsWith('/') ? url + 'index.md' : url + '/index.md';
                content = await tryFetch(mdUrl);
                if (content) isNative = true;
            }
            
            // Try r.jina.ai
            if (!content) {
                if (!url.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) {
                    const jinaUrl = 'https://r.jina.ai/' + (url.startsWith('http') ? url : '/' + url);
                    content = await tryFetch(jinaUrl);
                } else {
                    window.location.href = url;
                    return;
                }
            }
            
            stopTildeAnimation();
            
            if (content) {
                if (isNavigation) {
                    // Store both URL and source type in history
                    history.splice(currentIndex + 1);
                    history.push({ url, isNative });
                    currentIndex++;
                    backButton.classList.add('active');
                }
                updateSourceIndicator(isNative);
                contentDiv.innerHTML = parseMarkdown(content);
                setupLinks();
            } else {
                contentDiv.innerHTML = `<p>Could not load content from ${url}</p>`;
            }
        }

        // Update back button handler
        backButton.addEventListener('click', () => {
            if (currentIndex > 0) {
                currentIndex--;
                const previousEntry = history[currentIndex];
                urlInput.value = previousEntry.url;
                fetchContent(previousEntry.url, false);
                updateSourceIndicator(previousEntry.isNative);
                if (currentIndex === 0) {
                    backButton.classList.remove('active');
                }
            }
        });

        // Update source indicator
        function updateSourceIndicator(isNative) {
            document.querySelector('.native').classList.toggle('active', isNative);
            document.querySelector('.converted').classList.toggle('active', !isNative);
        }

        // Theme cycling
        const themes = ['light', 'dark', 'sepia'];
        const themeSymbols = ['☼', '☾', '∗'];
        let currentTheme = 0;
        
        document.querySelector('.mode-toggle').addEventListener('click', () => {
            currentTheme = (currentTheme + 1) % themes.length;
            document.body.className = themes[currentTheme];
            document.querySelector('.mode-toggle').textContent = themeSymbols[currentTheme];
            localStorage.setItem('theme', currentTheme);
            
            // Preserve RTL setting if active
            if (document.body.classList.contains('rtl')) {
                document.body.classList.add('rtl');
            }
        });

        // Restore theme
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme !== null) {
            currentTheme = parseInt(savedTheme);
            document.body.className = themes[currentTheme];
            document.querySelector('.mode-toggle').textContent = themeSymbols[currentTheme];
        }
        
        // Handle URL input
        urlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const url = e.target.value.trim();
                if (url) {
                    fetchContent(url);
                }
            }
        });

        function setupLinks() {
            document.querySelectorAll('#content a').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const url = link.getAttribute('href');
                    urlInput.value = url;
                    fetchContent(url);
                });
            });
        }

// Markdown parser based on Marked.js patterns
const parseMarkdown = (text) => {
    // Extract content after "Markdown Content:"
    const contentStart = text.indexOf("Markdown Content:");
    const content = contentStart !== -1 ? text.slice(contentStart + 17) : text;
    
    // Split into lines for processing
    const lines = content.split('\n');
    const processedLines = [];
    
    // First pass: Process tables and underline-style headers
    let i = 0;
    while (i < lines.length) {
        const line = lines[i];
        const nextLine = lines[i + 1] || '';
        
        // Check for underline-style headers (using marked.js approach)
        if (nextLine && !nextLine.trim().match(/^[^|]/) && (
            nextLine.trim().match(/^=+(?:=+)?$/) ||
            nextLine.trim().match(/^-+(?:-+)?$/)
        )) {
            if (nextLine.trim().match(/^=+(?:=+)?$/)) {
                processedLines.push('# ' + line);
            } else {
                processedLines.push('## ' + line);
            }
            i += 2; // Skip the underline
        }
        // Tables - using marked.js approach for detecting tables
        else if (
            line.trim().startsWith('|') && 
            line.trim().endsWith('|') && 
            nextLine && 
            nextLine.trim().startsWith('|') && 
            nextLine.trim().endsWith('|') && 
            nextLine.trim().match(/^[\s\-:|]+$/)
        ) {
            // Collect all table rows
            const tableRows = [];
            tableRows.push(line.trim());   // Header row
            tableRows.push(nextLine.trim()); // Separator row
            i += 2; // Skip header and separator
            
            // Collect additional rows
            while (i < lines.length && lines[i].trim().startsWith('|') && lines[i].trim().endsWith('|')) {
                tableRows.push(lines[i].trim());
                i++;
            }
            
            processedLines.push(renderTable(tableRows));
            continue;
        }
        else {
            processedLines.push(line);
            i++;
        }
    }
    
    // Join processed lines back to text
    let html = processedLines.join('\n');
    
    // Process block-level elements first (marked.js approach)
    
    // Code blocks with language identifier (```js code ```)
    html = html.replace(/```([a-zA-Z0-9_]+)?\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>');
    
    // Simple code blocks (indented by 4 spaces or 1 tab)
    html = html.replace(/^(?: {4}|\t)(.*)/gm, '<pre><code>$1</code></pre>');
    
    // Headers (ATX style with #)
    html = html.replace(/^(#{1,6})[ \t]+(.+?)[ \t]*#*$/gm, function(match, hashes, content) {
        const level = hashes.length;
        return `<h${level}>${content}</h${level}>`;
    });
    
    // Blockquotes
    html = html.replace(/^>[ \t]?(.+)$/gm, '<blockquote>$1</blockquote>');
    
    // Horizontal rules (using marked.js pattern)
    html = html.replace(/^(?:[\t ]*)(?:[-*_])(?:[\t ]*\1){2,}(?:[\t ]*)$/gm, '<hr>');
    
    // Images (using marked.js pattern)
    html = html.replace(/!\[((?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*)\]\(\s*<?([\s\S]*?)>?(?:\s+['"]([^\s]*)['"]\s*)?\)/g, 
                      '<img src="$2" alt="$1" title="$3">');
    
    // Links (using marked.js pattern)
    html = html.replace(/\[((?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*)\]\(\s*<?([\s\S]*?)>?(?:\s+['"]([^\s]*)['"]\s*)?\)/g, 
                      '<a href="$2" title="$3">$1</a>');
    
    // Strong (bold)
    html = html.replace(/\*\*([\s\S]+?)\*\*(?!\*)/g, '<strong>$1</strong>');
    html = html.replace(/__([\s\S]+?)__(?!_)/g, '<strong>$1</strong>');
    
    // Emphasis (italic)
    html = html.replace(/\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/gm, '<em>$1$2</em>');
    
    // Inline code
    html = html.replace(/(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/g, '<code>$2</code>');
    
    // Process lists (adapted from marked.js approach)
    html = processLists(html);
    
    // Paragraphs and line breaks
    html = html.replace(/\n\n+/g, '</p><p>');
    
    // Tables rendering function
    function renderTable(rows) {
        if (rows.length < 3) return rows.join('\n'); // Need at least header, separator, and one data row
        
        const headerRow = rows[0];
        const separatorRow = rows[1];
        const dataRows = rows.slice(2);
        
        // Parse header cells
        const headers = headerRow.split('|')
            .filter(cell => cell.trim() !== '')
            .map(cell => cell.trim());
        
        // Parse alignment from separator row
        const alignments = separatorRow.split('|')
            .filter(cell => cell.trim() !== '')
            .map(cell => {
                cell = cell.trim();
                if (cell.startsWith(':') && cell.endsWith(':')) return 'center';
                else if (cell.endsWith(':')) return 'right';
                else if (cell.startsWith(':')) return 'left';
                return '';
            });
        
        // Build table HTML
        let tableHTML = '<table>\n<thead>\n<tr>\n';
        
        // Add header cells
        headers.forEach((header, i) => {
            const align = alignments[i] ? ` align="${alignments[i]}"` : '';
            tableHTML += `<th${align}>${header}</th>\n`;
        });
        
        tableHTML += '</tr>\n</thead>\n<tbody>\n';
        
        // Add data rows
        dataRows.forEach(row => {
            const cells = row.split('|')
                .filter(cell => cell.trim() !== '')
                .map(cell => cell.trim());
            
            tableHTML += '<tr>\n';
            
            cells.forEach((cell, i) => {
                const align = alignments[i] ? ` align="${alignments[i]}"` : '';
                tableHTML += `<td${align}>${cell}</td>\n`;
            });
            
            tableHTML += '</tr>\n';
        });
        
        tableHTML += '</tbody>\n</table>';
        return tableHTML;
    }
    
    // Process lists (using patterns similar to marked.js)
    function processLists(html) {
        // Define list regex patterns
        const listItemRegex = /^( *)(?:[*+-]|\d+\.) +([^\n]*(?:\n(?!\1(?:[*+-]|\d+\.) )[^\n]*)*)(?:\n+|$)/gm;
        const bulletListStart = '<ul>\n';
        const bulletListEnd = '</ul>\n';
        const orderedListStart = '<ol>\n';
        const orderedListEnd = '</ol>\n';
        
        // Replace list items with HTML, tracking indentation
        const listStack = [];
        
        html = html.replace(listItemRegex, function(match, indent, text) {
            const isOrdered = match.match(/^\s*\d+\./);
            const listTag = isOrdered ? 'ol' : 'ul';
            const indentLevel = indent.length;
            let result = '';
            
            // Close lists if needed
            while (listStack.length > 0 && listStack[listStack.length - 1].indent > indentLevel) {
                const item = listStack.pop();
                result += item.type === 'ol' ? orderedListEnd : bulletListEnd;
            }
            
            // Start new list if needed
            if (listStack.length === 0 || listStack[listStack.length - 1].indent < indentLevel) {
                result += isOrdered ? orderedListStart : bulletListStart;
                listStack.push({ type: listTag, indent: indentLevel });
            } 
            // Close current list item if same level
            else if (listStack[listStack.length - 1].indent === indentLevel) {
                result += '</li>\n';
            }
            
            // Process text content - apply inline formatting
            text = text.trim()
                .replace(/\n+$/, '') // Remove trailing newlines
                .replace(/\n/g, '<br>'); // Convert internal newlines to <br>
            
            result += '<li>' + text;
            return result;
        });
        
        // Close any remaining open lists
        while (listStack.length > 0) {
            const item = listStack.pop();
            html += '</li>\n';
            html += item.type === 'ol' ? orderedListEnd : bulletListEnd;
        }
        
        return html;
    }
    
    return `<p>${html}</p>`;
};
    </script>
</body>
</html>
