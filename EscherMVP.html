<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>System Repair Puzzle</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .button {
            padding: 12px 24px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .button:hover {
            background-color: rgba(40, 40, 40, 0.8);
            transform: scale(1.05);
        }
        #manual-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 400px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 15px;
            color: white;
            overflow-y: auto;
            transform: translateX(350px);
            transition: transform 0.5s;
            z-index: 100;
        }
        #manual-container.visible {
            transform: translateX(0);
        }
        #manual-title {
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 5px;
        }
        #manual-content {
            font-size: 14px;
            line-height: 1.5;
        }
        .manual-section {
            margin-bottom: 15px;
        }
        .section-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #88ff8a;
        }
        #tracking-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-size: 14px;
            z-index: 100;
            display: none;
        }
        #progress-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 15px;
            color: white;
            text-align: center;
            z-index: 100;
        }
        #progress-bar {
            width: 100%;
            height: 20px;
            background-color: #333;
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }
        #progress {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        #results {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 25px;
            color: white;
            text-align: center;
            z-index: 200;
            display: none;
        }
        #results h2 {
            margin-top: 0;
            color: #88ff8a;
        }
        .score-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
        }
        .score-label {
            flex: 1;
            text-align: right;
            padding-right: 10px;
        }
        .score-value {
            flex: 1;
            text-align: left;
            padding-left: 10px;
        }
        .score-bar {
            width: 200px;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        .score-fill {
            height: 100%;
            background: linear-gradient(to right, #4c6baf 0%, #4CAF50 100%);
            width: 50%;
        }
        .score-marker {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background-color: white;
            left: 50%;
        }
        #job-matches {
            margin-top: 20px;
            text-align: left;
        }
        .job-match {
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 5px;
            background-color: rgba(255, 255, 255, 0.1);
        }
        #restart-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        #restart-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="ui-container">
        <button id="toggle-manual" class="button">Show Manual</button>
        <button id="reset-components" class="button">Reset Components</button>
        <button id="analyze-system" class="button">Analyze System</button>
    </div>

    <div id="manual-container">
        <div id="manual-title">System Repair Manual</div>
        <div id="manual-content">
            <div class="manual-section">
                <div class="section-title">1. Power Distribution</div>
                <p>Check power nodes A, B, and C for proper connection. Power flow should be sequential.</p>
            </div>
            <div class="manual-section">
                <div class="section-title">2. Data Processing</div>
                <p>Verify data cubes are properly aligned with the main circuit board. Color matching is essential.</p>
            </div>
            <div class="manual-section">
                <div class="section-title">3. Cooling System</div>
                <p>Ensure cooling rods are positioned at the correct angles. Overheating will occur if alignment is off by more than 15Â°.</p>
            </div>
            <div class="manual-section">
                <div class="section-title">4. Signal Calibration</div>
                <p>Signal nodes must be tuned to the correct frequency. Match the pattern shown on the oscilloscope.</p>
            </div>
            <div class="manual-section">
                <div class="section-title">5. Final Verification</div>
                <p>When all systems are operational, the central core should emit a steady green glow.</p>
            </div>
            <div class="manual-section">
                <div class="section-title">Troubleshooting</div>
                <p>- Red flashing: Power issue<br>
                - Yellow pulsing: Data misalignment<br>
                - Blue flickering: Cooling system fault<br>
                - No light: Signal calibration needed</p>
            </div>
        </div>
    </div>

    <div id="tracking-info">
        <div>Manual consulted: <span id="manual-count">0</span> times</div>
        <div>Experimental actions: <span id="experiment-count">0</span></div>
        <div>Systematic steps: <span id="systematic-count">0</span></div>
        <div>Approach: <span id="approach-score">Neutral</span></div>
    </div>

    <div id="progress-container">
        <div>System Repair Progress</div>
        <div id="progress-bar">
            <div id="progress"></div>
        </div>
    </div>

    <div id="results">
        <h2>Analysis Complete</h2>
        <p>Based on your problem-solving approach, we've analyzed your tendencies:</p>
        
        <div class="score-container">
            <div class="score-label">Systematic</div>
            <div class="score-bar">
                <div class="score-fill" id="approach-fill"></div>
                <div class="score-marker"></div>
            </div>
            <div class="score-value">Flexible</div>
        </div>
        
        <p>Your score suggests you tend to approach problems with a <span id="approach-text">balanced</span> mindset.</p>
        
        <div id="job-matches">
            <h3>Potential Job Matches:</h3>
            <div id="job-matches-content"></div>
        </div>
        
        <button id="restart-button">Try Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        // Custom fog for atmosphere
        scene.fog = new THREE.FogExp2(0x0a0a0a, 0.01);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.y = 1;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);
        
        // Add directional light (with shadows)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Add point lights for dramatic effect
        const pointLight1 = new THREE.PointLight(0x4CAF50, 1, 10);
        pointLight1.position.set(0, 2, 2);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0x6f4caf, 1, 10);
        pointLight2.position.set(-2, 1, -2);
        scene.add(pointLight2);
        
        // Create the main system structure
        const systemGeometry = new THREE.BoxGeometry(5, 0.5, 3);
        const systemMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x333333,
            specular: 0x111111,
            shininess: 30
        });
        const system = new THREE.Mesh(systemGeometry, systemMaterial);
        system.receiveShadow = true;
        scene.add(system);
        
        // Create the central core
        const coreGeometry = new THREE.SphereGeometry(0.4, 32, 32);
        const coreMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff3333,
            emissive: 0x440000,
            shininess: 50
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        core.position.y = 0.7;
        core.castShadow = true;
        scene.add(core);
        
        // Create power nodes
        const powerNodes = [];
        const nodePositions = [
            new THREE.Vector3(-1.5, 0.5, -0.8),
            new THREE.Vector3(-0.5, 0.5, -0.8),
            new THREE.Vector3(0.5, 0.5, -0.8)
        ];
        
        const nodeGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 16);
        const nodeMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x666666,
            emissive: 0x222222,
            shininess: 30
        });
        
        nodePositions.forEach((position, index) => {
            const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
            node.position.copy(position);
            node.rotation.x = Math.PI / 2;
            node.castShadow = true;
            scene.add(node);
            powerNodes.push({
                mesh: node,
                active: false,
                index: index
            });
        });
        
        // Create data cubes
        const dataCubes = [];
        const cubePositions = [
            new THREE.Vector3(-1.5, 0.5, 0.8),
            new THREE.Vector3(-0.5, 0.5, 0.8),
            new THREE.Vector3(0.5, 0.5, 0.8),
            new THREE.Vector3(1.5, 0.5, 0.8)
        ];
        
        const cubeColors = [
            0x4287f5, // Blue
            0xf54242, // Red
            0x42f554, // Green
            0xf5e042  // Yellow
        ];
        
        const cubeGeometry = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        
        cubePositions.forEach((position, index) => {
            const cubeMaterial = new THREE.MeshPhongMaterial({ 
                color: cubeColors[index],
                emissive: new THREE.Color(cubeColors[index]).multiplyScalar(0.2),
                shininess: 50
            });
            
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.copy(position);
            cube.rotation.y = Math.PI / 4;
            cube.castShadow = true;
            scene.add(cube);
            dataCubes.push({
                mesh: cube,
                active: false,
                correctPosition: index,
                currentPosition: index
            });
        });
        
        // Create cooling rods
        const coolingRods = [];
        const rodPositions = [
            new THREE.Vector3(-1.8, 0.5, 0),
            new THREE.Vector3(1.8, 0.5, 0)
        ];
        
        const rodGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 16);
        const rodMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x66ccff,
            emissive: 0x113344,
            shininess: 50
        });
        
        rodPositions.forEach((position, index) => {
            const rod = new THREE.Mesh(rodGeometry, rodMaterial.clone());
            rod.position.copy(position);
            rod.rotation.z = Math.PI / 2;
            rod.castShadow = true;
            scene.add(rod);
            coolingRods.push({
                mesh: rod,
                active: false,
                correctRotation: 0,
                currentRotation: Math.random() * Math.PI / 2 - Math.PI / 4
            });
            rod.rotation.x = coolingRods[index].currentRotation;
        });
        
        // Create signal nodes
        const signalNodes = [];
        const signalPositions = [
            new THREE.Vector3(1.5, 0.5, -0.8)
        ];
        
        const signalGeometry = new THREE.TorusGeometry(0.2, 0.05, 16, 32);
        const signalMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff66cc,
            emissive: 0x331133,
            shininess: 50
        });
        
        signalPositions.forEach((position, index) => {
            const signal = new THREE.Mesh(signalGeometry, signalMaterial);
            signal.position.copy(position);
            signal.rotation.x = Math.PI / 2;
            signal.castShadow = true;
            scene.add(signal);
            signalNodes.push({
                mesh: signal,
                active: false
            });
        });
        
        // Create connecting lines
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4CAF50, transparent: true, opacity: 0.5 });
        
        // Function to create line between two points
        function createConnectionLine(pointA, pointB) {
            const geometry = new THREE.BufferGeometry().setFromPoints([pointA, pointB]);
            const line = new THREE.Line(geometry, lineMaterial);
            scene.add(line);
            return line;
        }
        
        // Connect core to various components
        const connectionLines = [];
        
        // Connect core to power nodes
        powerNodes.forEach(node => {
            connectionLines.push(createConnectionLine(
                core.position,
                node.mesh.position
            ));
        });
        
        // Connect core to data cubes
        dataCubes.forEach(cube => {
            connectionLines.push(createConnectionLine(
                core.position,
                cube.mesh.position
            ));
        });
        
        // Connect core to cooling rods
        coolingRods.forEach(rod => {
            connectionLines.push(createConnectionLine(
                core.position,
                rod.mesh.position
            ));
        });
        
        // Connect core to signal nodes
        signalNodes.forEach(signal => {
            connectionLines.push(createConnectionLine(
                core.position,
                signal.mesh.position
            ));
        });
        
        // Interaction setup
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Tracking variables for behavior analysis
        let manualConsultCount = 0;
        let experimentActionCount = 0;
        let systematicStepCount = 0;
        let currentStep = 0;
        let systematicApproach = 0; // -1 to 1 (flexible to systematic)
        
        // Systems to fix
        const systems = [
            { name: "Power Distribution", fixed: false, manualSection: 1 },
            { name: "Data Processing", fixed: false, manualSection: 2 },
            { name: "Cooling System", fixed: false, manualSection: 3 },
            { name: "Signal Calibration", fixed: false, manualSection: 4 }
        ];
        
        // Track if manual is visible
        let manualVisible = false;
        
        // UI event listeners
        document.getElementById('toggle-manual').addEventListener('click', () => {
            const manualContainer = document.getElementById('manual-container');
            manualVisible = !manualVisible;
            
            if (manualVisible) {
                manualContainer.classList.add('visible');
                document.getElementById('toggle-manual').textContent = 'Hide Manual';
                manualConsultCount++;
                document.getElementById('manual-count').textContent = manualConsultCount;
                systematicApproach += 0.1;
                updateApproachScore();
            } else {
                manualContainer.classList.remove('visible');
                document.getElementById('toggle-manual').textContent = 'Show Manual';
            }
        });
        
        document.getElementById('reset-components').addEventListener('click', () => {
            resetComponents();
            experimentActionCount++;
            document.getElementById('experiment-count').textContent = experimentActionCount;
            systematicApproach -= 0.1;
            updateApproachScore();
        });
        
        document.getElementById('analyze-system').addEventListener('click', () => {
            analyzeSystem();
            systematicStepCount++;
            document.getElementById('systematic-count').textContent = systematicStepCount;
            systematicApproach += 0.15;
            updateApproachScore();
        });
        
        document.getElementById('restart-button').addEventListener('click', () => {
            document.getElementById('results').style.display = 'none';
            resetSimulation();
        });
        
        // Function to update approach score display
        function updateApproachScore() {
            // Clamp value between -1 and 1
            systematicApproach = Math.max(-1, Math.min(1, systematicApproach));
            
            let approachText = "Balanced";
            if (systematicApproach > 0.3) approachText = "Somewhat Systematic";
            if (systematicApproach > 0.6) approachText = "Highly Systematic";
            if (systematicApproach < -0.3) approachText = "Somewhat Flexible";
            if (systematicApproach < -0.6) approachText = "Highly Flexible";
            
            document.getElementById('approach-score').textContent = approachText;
        }
        
        // Click event for object interaction
        window.addEventListener('click', onMouseClick, false);
        window.addEventListener('touchend', onTouchEnd, false);
        
        function onTouchEnd(event) {
            // Convert touch to mouse position
            event.preventDefault();
            event.clientX = event.changedTouches[0].clientX;
            event.clientY = event.changedTouches[0].clientY;
            onMouseClick(event);
        }
        
        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                // Check if it's a power node
                const powerNodeIndex = powerNodes.findIndex(node => node.mesh === object);
                if (powerNodeIndex !== -1) {
                    togglePowerNode(powerNodeIndex);
                    return;
                }
                
                // Check if it's a data cube
                const dataCubeIndex = dataCubes.findIndex(cube => cube.mesh === object);
                if (dataCubeIndex !== -1) {
                    rotateCube(dataCubeIndex);
                    return;
                }
                
                // Check if it's a cooling rod
                const coolingRodIndex = coolingRods.findIndex(rod => rod.mesh === object);
                if (coolingRodIndex !== -1) {
                    adjustCoolingRod(coolingRodIndex);
                    return;
                }
                
                // Check if it's a signal node
                const signalNodeIndex = signalNodes.findIndex(signal => signal.mesh === object);
                if (signalNodeIndex !== -1) {
                    adjustSignalNode(signalNodeIndex);
                    return;
                }
                
                // Check if it's the core
                if (object === core) {
                    pulseCore();
                    return;
                }
            }
        }
        
        // Function to toggle power node
        function togglePowerNode(index) {
            const node = powerNodes[index];
            node.active = !node.active;
            
            // Update appearance
            if (node.active) {
                node.mesh.material.emissive.set(0x005500);
                node.mesh.material.color.set(0x4CAF50);
            } else {
                node.mesh.material.emissive.set(0x222222);
                node.mesh.material.color.set(0x666666);
            }
            
            // Check if all power nodes are active and in sequence
            checkPowerSystem();
            
            // Record interaction
            if (manualVisible && currentStep === 0) {
                systematicStepCount++;
                document.getElementById('systematic-count').textContent = systematicStepCount;
                systematicApproach += 0.05;
            } else {
                experimentActionCount++;
                document.getElementById('experiment-count').textContent = experimentActionCount;
                systematicApproach -= 0.05;
            }
            updateApproachScore();
            
            updateProgress();
        }
        
        // Function to rotate data cube (representing data alignment)
        function rotateCube(index) {
            const cube = dataCubes[index];
            cube.mesh.rotation.y += Math.PI / 2;
            
            // Update tracking
            cube.currentPosition = (cube.currentPosition + 1) % 4;
            
            // Check if all data cubes are in correct position
            checkDataSystem();
            
            // Record interaction
            if (manualVisible && currentStep === 1) {
                systematicStepCount++;
                document.getElementById('systematic-count').textContent = systematicStepCount;
                systematicApproach += 0.05;
            } else {
                experimentActionCount++;
                document.getElementById('experiment-count').textContent = experimentActionCount;
                systematicApproach -= 0.05;
            }
            updateApproachScore();
            
            updateProgress();
        }
        
        // Function to adjust cooling rod
        function adjustCoolingRod(index) {
            const rod = coolingRods[index];
            rod.currentRotation += Math.PI / 12;
            if (rod.currentRotation > Math.PI / 2) {
                rod.currentRotation = -Math.PI / 2;
            }
            
            rod.mesh.rotation.x = rod.currentRotation;
            
            // Check if cooling rods are properly aligned
            checkCoolingSystem();
            
            // Record interaction
            if (manualVisible && currentStep === 2) {
                systematicStepCount++;
                document.getElementById('systematic-count').textContent = systematicStepCount;
                systematicApproach += 0.05;
            } else {
                experimentActionCount++;
                document.getElementById('experiment-count').textContent = experimentActionCount;
                systematicApproach -= 0.05;
            }
            updateApproachScore();
            
            updateProgress();
        }
        
        // Function to adjust signal node
        function adjustSignalNode(index) {
            const signal = signalNodes[index];
            signal.active = !signal.active;
            
            // Update appearance
            if (signal.active) {
                signal.mesh.material.emissive.set(0x550055);
                signal.mesh.material.color.set(0xff66ff);
            } else {
                signal.mesh.material.emissive.set(0x331133);
                signal.mesh.material.color.set(0xff66cc);
            }
            
            // Check if signal is calibrated
            checkSignalSystem();
            
            // Record interaction
            if (manualVisible && currentStep === 3) {
                systematicStepCount++;
                document.getElementById('systematic-count').textContent = systematicStepCount;
                systematicApproach += 0.05;
            } else {
                experimentActionCount++;
                document.getElementById('experiment-count').textContent = experimentActionCount;
                systematicApproach -= 0.05;
            }
            updateApproachScore();
            
            updateProgress();
        }
        
        // Function to pulse the core (visual feedback)
        function pulseCore() {
            const originalScale = core.scale.clone();
            const timeline = { t: 0 };
            
            // Simple animation using requestAnimationFrame
            function animate() {
                timeline.t += 0.05;
                const scale = 1 + 0.2 * Math.sin(timeline.t * Math.PI * 2);
                
                core.scale.set(scale, scale, scale);
                
                if (timeline.t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    core.scale.copy(originalScale);
                }
            }
            
            animate();
            
            // Record interaction
            experimentActionCount++;
            document.getElementById('experiment-count').textContent = experimentActionCount;
        }
        
        // System checking functions
        function checkPowerSystem() {
            // Power needs to be in sequence A -> B -> C
            if (powerNodes[0].active && powerNodes[1].active && powerNodes[2].active) {
                systems[0].fixed = true;
                if (currentStep === 0) {
                    currentStep = 1;
                }
            } else {
                systems[0].fixed = false;
            }
            
            updateCoreState();
        }
        
        function checkDataSystem() {
            // All data cubes need to be in the correct position
            const allCorrect = dataCubes.every(cube => 
                cube.currentPosition === cube.correctPosition);
            
            systems[1].fixed = allCorrect;
            
            if (allCorrect && currentStep === 1) {
                currentStep = 2;
            }
            
            updateCoreState();
        }
        
        function checkCoolingSystem() {
            // Cooling rods need to be within 15 degrees of correct rotation
            const tolerance = Math.PI / 12; // 15 degrees
            
            const allAligned = coolingRods.every(rod => 
                Math.abs(rod.currentRotation - rod.correctRotation) < tolerance);
            
            systems[2].fixed = allAligned;
            
            if (allAligned && currentStep === 2) {
                currentStep = 3;
            }
            
            updateCoreState();
        }
        
        function checkSignalSystem() {
            // Signal nodes need to be active
            const allCalibrated = signalNodes.every(signal => signal.active);
            
            systems[3].fixed = allCalibrated;
            
            if (allCalibrated && currentStep === 3) {
                currentStep = 4;
                systemFixed();
            }
            
            updateCoreState();
        }
        
        // Update central core visual state
        function updateCoreState() {
            // Count fixed systems
            const fixedCount = systems.filter(sys => sys.fixed).length;
            
            // Update core appearance based on fixed count
            if (fixedCount === 0) {
                core.material.color.set(0xff3333); // Red
                core.material.emissive.set(0x440000);
            } else if (fixedCount === 1) {
                core.material.color.set(0xff6633); // Orange
                core.material.emissive.set(0x442200);
            } else if (fixedCount === 2) {
                core.material.color.set(0xffcc33); // Yellow
                core.material.emissive.set(0x443300);
            } else if (fixedCount === 3) {
                core.material.color.set(0xccff33); // Yellow-green
                core.material.emissive.set(0x334400);
            } else if (fixedCount === 4) {
                core.material.color.set(0x4CAF50); // Green
                core.material.emissive.set(0x004400);
            }
        }
        
        // Reset components to initial state but keep behavioral tracking
        function resetComponents() {
            // Reset power nodes
            powerNodes.forEach(node => {
                node.active = false;
                node.mesh.material.emissive.set(0x222222);
                node.mesh.material.color.set(0x666666);
            });
            
            // Reset data cubes (randomize positions)
            dataCubes.forEach(cube => {
                const randomRotations = Math.floor(Math.random() * 4);
                for (let i = 0; i < randomRotations; i++) {
                    cube.mesh.rotation.y += Math.PI / 2;
                    cube.currentPosition = (cube.currentPosition + 1) % 4;
                }
            });
            
            // Reset cooling rods
            coolingRods.forEach(rod => {
                rod.currentRotation = Math.random() * Math.PI / 2 - Math.PI / 4;
                rod.mesh.rotation.x = rod.currentRotation;
            });
            
            // Reset signal nodes
            signalNodes.forEach(signal => {
                signal.active = false;
                signal.mesh.material.emissive.set(0x331133);
                signal.mesh.material.color.set(0xff66cc);
            });
            
            // Reset systems
            systems.forEach(system => {
                system.fixed = false;
            });
            
            // Reset current step
            currentStep = 0;
            
            // Update core
            updateCoreState();
            
            // Update progress
            updateProgress();
        }
        
        // Full simulation reset (including behavioral tracking)
        function resetSimulation() {
            resetComponents();
            
            // Reset behavior tracking
            manualConsultCount = 0;
            experimentActionCount = 0;
            systematicStepCount = 0;
            systematicApproach = 0;
            
            document.getElementById('manual-count').textContent = manualConsultCount;
            document.getElementById('experiment-count').textContent = experimentActionCount;
            document.getElementById('systematic-count').textContent = systematicStepCount;
            updateApproachScore();
            
            // Show tracking info during dev/testing
            document.getElementById('tracking-info').style.display = 'block';
        }
        
        // Function to analyze the current system
        function analyzeSystem() {
            // Count fixed systems
            const fixedCount = systems.filter(sys => sys.fixed).length;
            const totalSystems = systems.length;
            
            // Flash the core to indicate analysis
            const originalColor = core.material.color.clone();
            const originalEmissive = core.material.emissive.clone();
            
            core.material.color.set(0xffffff);
            core.material.emissive.set(0x444444);
            
            setTimeout(() => {
                core.material.color.copy(originalColor);
                core.material.emissive.copy(originalEmissive);
                
                // Show any issues
                let issueSystems = systems.filter(sys => !sys.fixed);
                if (issueSystems.length > 0) {
                    // Highlight the first unfixed system component
                    highlightSystem(issueSystems[0]);
                }
            }, 500);
        }
        
        // Function to highlight a system that needs fixing
        function highlightSystem(system) {
            // Visual indication for which system needs attention
            let targetObjects = [];
            
            if (system.name === "Power Distribution") {
                targetObjects = powerNodes.map(node => node.mesh);
            } else if (system.name === "Data Processing") {
                targetObjects = dataCubes.map(cube => cube.mesh);
            } else if (system.name === "Cooling System") {
                targetObjects = coolingRods.map(rod => rod.mesh);
            } else if (system.name === "Signal Calibration") {
                targetObjects = signalNodes.map(signal => signal.mesh);
            }
            
            // Flash the objects
            const originalMaterials = targetObjects.map(obj => obj.material.clone());
            
            // Highlight color
            targetObjects.forEach(obj => {
                obj.material.emissive.set(0x444444);
                obj.material.color.set(0xffffff);
            });
            
            // Reset after delay
            setTimeout(() => {
                targetObjects.forEach((obj, index) => {
                    obj.material.color.copy(originalMaterials[index].color);
                    obj.material.emissive.copy(originalMaterials[index].emissive);
                });
            }, 1000);
        }
        
        // Update progress bar
        function updateProgress() {
            const fixedCount = systems.filter(sys => sys.fixed).length;
            const totalSystems = systems.length;
            const percentage = (fixedCount / totalSystems) * 100;
            
            document.getElementById('progress').style.width = percentage + '%';
        }
        
        // System fully fixed
        function systemFixed() {
            // Celebratory animation
            const timeline = { t: 0 };
            const originalScale = core.scale.clone();
            const originalColor = core.material.color.clone();
            const originalEmissive = core.material.emissive.clone();
            
            function celebrateAnimation() {
                timeline.t += 0.02;
                
                // Pulsating size and brightness
                const scale = 1 + 0.3 * Math.sin(timeline.t * Math.PI * 4);
                core.scale.set(scale, scale, scale);
                
                // Cycle through colors
                const hue = (timeline.t * 2) % 1;
                const color = new THREE.Color().setHSL(hue, 1, 0.5);
                core.material.color.copy(color);
                core.material.emissive.copy(color).multiplyScalar(0.5);
                
                if (timeline.t < 1) {
                    requestAnimationFrame(celebrateAnimation);
                } else {
                    // Reset to final green state
                    core.scale.copy(originalScale);
                    core.material.color.set(0x4CAF50);
                    core.material.emissive.set(0x004400);
                    
                    // Show results
                    showResults();
                }
            }
            
            celebrateAnimation();
        }
        
        // Show results screen
        function showResults() {
            const resultsElement = document.getElementById('results');
            resultsElement.style.display = 'block';
            
            // Clamp score between -1 and 1
            systematicApproach = Math.max(-1, Math.min(1, systematicApproach));
            
            // Set the fill percentage (convert -1...1 to 0%...100%)
            const fillPercentage = ((systematicApproach + 1) / 2) * 100;
            document.getElementById('approach-fill').style.width = fillPercentage + '%';
            
            // Set the approach text
            let approachText = "balanced";
            let jobMatches = [];
            
            if (systematicApproach > 0.6) {
                approachText = "highly systematic";
                jobMatches = [
                    "Quality Control Specialist",
                    "Accountant/Auditor",
                    "Compliance Officer",
                    "Air Traffic Controller",
                    "Medical Lab Technician"
                ];
            } else if (systematicApproach > 0.2) {
                approachText = "somewhat systematic";
                jobMatches = [
                    "Engineer",
                    "Software Developer",
                    "Data Analyst",
                    "Project Manager",
                    "Medical Professional"
                ];
            } else if (systematicApproach < -0.6) {
                approachText = "highly flexible/creative";
                jobMatches = [
                    "Graphic Designer",
                    "Marketing Creative",
                    "Entrepreneur",
                    "Product Designer",
                    "Innovation Consultant"
                ];
            } else if (systematicApproach < -0.2) {
                approachText = "somewhat flexible";
                jobMatches = [
                    "Product Manager",
                    "UX Designer",
                    "Sales Representative",
                    "Customer Success Manager",
                    "General Management"
                ];
            } else {
                approachText = "balanced";
                jobMatches = [
                    "Team Lead",
                    "General Management",
                    "Business Analyst",
                    "Full-stack Developer",
                    "Technical Writer"
                ];
            }
            
            document.getElementById('approach-text').textContent = approachText;
            
            // Populate job matches
            const jobMatchesContent = document.getElementById('job-matches-content');
            jobMatchesContent.innerHTML = '';
            
            jobMatches.forEach(job => {
                const jobElement = document.createElement('div');
                jobElement.className = 'job-match';
                jobElement.textContent = job;
                jobMatchesContent.appendChild(jobElement);
            });
        }
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate the data cubes slightly for visual interest
            dataCubes.forEach(cube => {
                cube.mesh.rotation.x += 0.003;
                cube.mesh.rotation.z += 0.002;
            });
            
            // Rotate the signal nodes
            signalNodes.forEach(signal => {
                signal.mesh.rotation.z += 0.01;
            });
            
            // Orbit camera slightly
            const time = Date.now() * 0.0005;
            camera.position.x = Math.sin(time) * 5;
            camera.position.z = Math.cos(time) * 5;
            camera.lookAt(0, 0.7, 0);
            
            renderer.render(scene, camera);
        }
        
        // Initialize
        resetSimulation();
        animate();
    </script>
</body>
</html>
